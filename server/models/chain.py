import mysql.connector
from utils.connect_to_db import connect_to_db
from flask import jsonify


def get_chains():
    try:
        connection = connect_to_db()
        cursor = connection.cursor()

        # Fetch all reports
        chains_query = "SELECT * FROM chain"
        cursor.execute(chains_query)
        chains = cursor.fetchall()

        # Get column names
        column_names = [desc[0] for desc in cursor.description]

        # Prepare the response
        chains_response = []
        for chain in chains:
            chains_response.append(dict(zip(column_names, chain)))

        return jsonify({"items": chains_response}), 200

    except mysql.connector.Error as err:
        return jsonify({"error": str(err)}), 500
    finally:
        cursor.close()
        connection.close()


def store_chain(chain_name, type):
    try:
        # Establish a connection to the database
        connection = connect_to_db()
        cursor = connection.cursor()

        # Create a chain entry in the chain table
        insert_chain_query = """
        INSERT INTO chain (name, type)
        VALUES (%s, %s)
        """
        cursor.execute(
            insert_chain_query,
            (chain_name, type),
        )

        # Get the ID of the newly created chain
        chain_id = cursor.lastrowid

        # Commit the changes
        connection.commit()

        # Return the report ID
        return chain_id

    except mysql.connector.Error as err:
        print(f"Error Storing chain data: {err}")
    finally:
        cursor.close()
        connection.close()


def store_chain_model_metrics(chain_id, new_model_id, created_at=None):
    try:
        # Establish a connection to the database
        connection = connect_to_db()
        cursor = connection.cursor()

        # Prepare the SQL query and parameters
        if created_at:
            insert_query = """
                INSERT INTO chain_model_metrics (chain_id, model_metrics_id, created_at)
                VALUES (%s, %s, %s)
            """
            parameters = (chain_id, new_model_id, created_at)
        else:
            insert_query = """
                INSERT INTO chain_model_metrics (chain_id, model_metrics_id)
                VALUES (%s, %s)
            """
            parameters = (chain_id, new_model_id)

        # Execute the insert query
        cursor.execute(insert_query, parameters)

        # Commit the changes
        connection.commit()

    except mysql.connector.Error as err:
        print(f"Error Storing chain_model_metrics data: {err}")
    finally:
        cursor.close()
        connection.close()


def get_latest_chain_model_metrics():
    # Create a connection
    try:
        connection = connect_to_db()
        cursor = connection.cursor()

        # SQL query to get the latest chain model metrics
        query = """
        WITH LatestMetrics AS (
            SELECT 
                chain_id,
                model_metrics_id,
                created_at,
                ROW_NUMBER() OVER (PARTITION BY chain_id ORDER BY created_at DESC) AS rn
            FROM 
                chain_model_metrics
        )
        SELECT 
            c.id AS chain_id,
            c.name AS chain_name,
            c.type AS chain_type,
            lm.model_metrics_id,
            lm.created_at
        FROM 
            LatestMetrics lm
        JOIN 
            chain c ON lm.chain_id = c.id
        WHERE 
            lm.rn = 1;
        """

        # Execute the query
        cursor.execute(query)

        # Fetch results
        results = cursor.fetchall()

        # Prepare the output
        formatted_results = []
        for row in results:
            chain_id, chain_name, chain_type, model_metrics_id, _ = row
            formatted_results.append(
                {
                    "id": model_metrics_id,
                    "label": f"{chain_type.capitalize()} // {model_metrics_id}",
                    "value": model_metrics_id,
                    "report": f"Chain: {chain_name}",
                    "chain_name": chain_name,
                    "chain_id": chain_id,
                    "type": chain_type,
                }
            )

        return formatted_results

    except mysql.connector.Error as err:
        print(f"Error: {err}")
    finally:
        # Clean up and close the connection
        if cursor:
            cursor.close()
        if connection:
            connection.close()


def get_model_metrics_by_chain(chain_id):
    # Create a connection
    try:
        connection = connect_to_db()
        cursor = connection.cursor()

        # SQL query to get model metrics by chain id, including created_at from chain_model_metrics
        query = """
        SELECT 
            c.id AS chain_id,
            c.name AS chain_name,
            c.type AS chain_type,
            mm.*,
            cm.created_at AS created_at
        FROM 
            chain c
        JOIN 
            chain_model_metrics cm ON c.id = cm.chain_id
        JOIN 
            model_metrics mm ON cm.model_metrics_id = mm.id
        WHERE 
            c.id = %s
        ORDER BY 
            cm.created_at ASC;
        """

        # Execute the query
        cursor.execute(query, (chain_id,))
        results = cursor.fetchall()

        # Prepare the output structure
        response = {
            "metadata": {"chain_id": None, "chain_name": None, "chain_type": None},
            "items": [],
        }

        # Column names for model_metrics
        column_names = [i[0] for i in cursor.description]

        # Populate metadata and items
        for row in results:
            # First item in each row corresponds to chain data
            chain_id, chain_name, chain_type = row[:3]

            # Set metadata (assumes the same chain for all rows)
            if response["metadata"]["chain_id"] is None:
                response["metadata"]["chain_id"] = chain_id
                response["metadata"]["chain_name"] = chain_name
                response["metadata"]["chain_type"] = chain_type

            # Create a dictionary for the model metrics
            metrics = {column_names[i]: row[i] for i in range(len(column_names))}

            # Append the metrics to the items list
            response["items"].append(metrics)

        return response

    except mysql.connector.Error as err:
        print(f"Error: {err}")
        return None
    finally:
        if cursor:
            cursor.close()
        if connection:
            connection.close()

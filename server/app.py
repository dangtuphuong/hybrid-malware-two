import json
from flask import Flask, request, jsonify
from flask_cors import CORS
from mysql.connector import Error
from models.train import train_models
from models.predict import predict_from_model
from models.chain import chain_model
from utils.connect_to_db import connect_to_db
from utils.store_to_db import store_metrics
import joblib

app = Flask(__name__)
CORS(app)


@app.route("/api/authenticate", methods=["POST"])
def authenticate_user():
    data = request.json
    email = data.get("email")
    password = data.get("password")

    if not email or not password:
        return jsonify({"error": "Missing email or password"}), 400

    connection = connect_to_db()
    if not connection:
        return jsonify({"error": "Unable to connect to the database"}), 500

    try:
        cursor = connection.cursor(dictionary=True)
        cursor.execute(
            "SELECT * FROM users WHERE email = %s AND password = %s", (email, password)
        )
        user = cursor.fetchone()

        if user:
            return jsonify({"message": "Authentication successful", "user": user}), 200
        else:
            return jsonify({"error": "Invalid email or password"}), 401
    except Error as e:
        return jsonify({"error": str(e)}), 500
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()


@app.route("/api/register", methods=["POST"])
def register_user():
    data = request.json
    name = data.get("name")
    email = data.get("email")
    password = data.get("password")
    role = data.get("role")

    if not name or not email or not password or not role:
        return jsonify({"error": "Missing name, email, password, or role"}), 400

    if role not in [0, 1]:
        return jsonify({"error": "Role must be either 0 or 1"}), 400

    connection = connect_to_db()
    if not connection:
        return jsonify({"error": "Unable to connect to the database"}), 500

    try:
        cursor = connection.cursor()

        # Insert user into the database
        sql = "INSERT INTO users (name, email, password, role) VALUES (%s, %s, %s, %s)"
        val = (name, email, password, role)
        cursor.execute(sql, val)

        connection.commit()

        # Fetch the newly registered user
        cursor.execute(
            "SELECT id, name, email, role FROM users WHERE email = %s", (email,)
        )
        user_data = cursor.fetchone()
        if user_data:
            user = {
                "id": user_data[0],
                "name": user_data[1],
                "email": user_data[2],
                "role": user_data[3],
            }
            return (
                jsonify({"message": "User registered successfully", "user": user}),
                200,
            )
        else:
            return jsonify({"error": "User registration failed"}), 500

    except Error as e:
        return jsonify({"error": str(e)}), 500

    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()


@app.route("/api/train", methods=["POST"])
def train():
    try:
        file = request.files["file"]
        separator = request.form["separator"]
        feature_columns = request.form["features"].split(separator)
        target_column = request.form["target"]
        name = request.form["name"]
        created_by = request.form["created_by"]
        train_models_str = request.form["train_models_str"]

        malware_distribution, knn_metrics, lgbm_metrics, hybrid_metrics, model_ids = (
            train_models(
                file, separator, feature_columns, target_column, train_models_str
            )
        )

        # Attempt to store metrics in the database
        report_id = None
        try:
            report_id = store_metrics(
                malware_distribution,
                knn_metrics,
                lgbm_metrics,
                hybrid_metrics,
                model_ids,
                name,
                created_by,
            )
        except Exception as store_error:
            return (
                jsonify({"error": "Failed to store metrics: " + str(store_error)}),
                500,
            )

        return (
            jsonify(
                {
                    "knn_metrics": knn_metrics,
                    "lgbm_metrics": lgbm_metrics,
                    "hybrid_metrics": hybrid_metrics,
                    "model_ids": model_ids,
                    "report_id": report_id,
                }
            ),
            200,
        )

    except Exception as e:
        return jsonify({"error": "An unexpected error occurred: " + str(e)}), 500


@app.route("/api/predict", methods=["POST"])
def predict():
    try:
        file = request.files["file"]
        model_id = request.form["model_id"]
        key_column = (
            request.form.get("key_column") or None
            if request.form.get("key_column") != ""
            else None
        )

        results = predict_from_model(file, model_id, key_column)

        return jsonify(results), 200

    except FileNotFoundError as e:
        return jsonify({"error": str(e)}), 404
    except ValueError as e:
        return jsonify({"error": str(e)}), 400
    except Exception as e:
        return jsonify({"error": "An unexpected error occurred: " + str(e)}), 500


@app.route("/api/report/<report_id>", methods=["GET"])
def get_report(report_id):
    try:
        connection = connect_to_db()
        cursor = connection.cursor()

        # Fetch the report by ID, including additional details
        report_query = """
        SELECT name, created_at, created_by, knn_model_id, lgbm_model_id, hybrid_model_id, malware_distribution
        FROM report
        WHERE id = %s
        """
        cursor.execute(report_query, (report_id,))
        report = cursor.fetchone()

        if report is None:
            return jsonify({"error": "Report not found"}), 404

        (
            name,
            created_at,
            created_by,
            knn_model_id,
            lgbm_model_id,
            hybrid_model_id,
            malware_distribution,
        ) = report

        # Prepare the response
        metrics_response = {}
        model_ids = [knn_model_id, lgbm_model_id, hybrid_model_id]
        model_names = [
            "Hybrid" if hybrid_model_id else None,
            "K-Nearest Neighors" if knn_model_id else None,
            "LightGBM" if lgbm_model_id else None,
        ]

        # Filter out None model IDs
        valid_model_ids = [model_id for model_id in model_ids if model_id is not None]
        valid_model_names = [
            model_name for model_name in model_names if model_name is not None
        ]

        # Fetch metrics for each model
        model_metrics_query = """
        SELECT accuracy, `precision`, recall, f1, classification_report
        FROM model_metrics
        WHERE id IN (%s, %s, %s)
        """
        cursor.execute(
            model_metrics_query, (knn_model_id, lgbm_model_id, hybrid_model_id)
        )
        metrics = cursor.fetchall()

        for i, model_id in enumerate(valid_model_ids):
            if i < len(metrics) and metrics[i]:
                metrics_response[valid_model_names[i]] = {
                    "id": model_id,
                    "accuracy": metrics[i][0],
                    "precision": metrics[i][1],
                    "recall": metrics[i][2],
                    "f1": metrics[i][3],
                    "classification_report": json.loads(metrics[i][4]),
                }

        return (
            jsonify(
                {
                    "report": {
                        "report_id": report_id,
                        "name": name,
                        "created_at": created_at,
                        "created_by": created_by,
                        "malware_distribution": json.loads(malware_distribution),
                    },
                    "models": metrics_response,
                }
            ),
            200,
        )

    except Error as err:
        return jsonify({"error": str(err)}), 500
    finally:
        cursor.close()
        connection.close()


@app.route("/api/reports", methods=["GET"])
def get_all_reports():
    try:
        connection = connect_to_db()
        cursor = connection.cursor()

        # Fetch all reports
        reports_query = "SELECT * FROM report"
        cursor.execute(reports_query)
        reports = cursor.fetchall()

        # Get column names
        column_names = [desc[0] for desc in cursor.description]

        # Prepare the response
        reports_response = []
        for report in reports:
            reports_response.append(dict(zip(column_names, report)))

        return jsonify({"items": reports_response}), 200

    except Error as err:
        return jsonify({"error": str(err)}), 500
    finally:
        cursor.close()
        connection.close()


@app.route("/api/models", methods=["GET"])
def get_all_models():
    try:
        connection = connect_to_db()
        cursor = connection.cursor()

        # Fetch all reports
        reports_query = "SELECT * FROM report"
        cursor.execute(reports_query)
        reports = cursor.fetchall()

        # Get column names
        column_names = [desc[0] for desc in cursor.description]

        # Prepare the response
        reports_response = []
        for report in reports:
            reports_response.append(dict(zip(column_names, report)))

        # Map Models
        models = []

        if reports_response:
            for report in reports_response:
                name = report.get("name")
                created_at = report.get("created_at")
                hybrid_model_id = report.get("hybrid_model_id")
                knn_model_id = report.get("knn_model_id")
                lgbm_model_id = report.get("lgbm_model_id")

                if hybrid_model_id:
                    models.append(
                        {
                            "id": hybrid_model_id,
                            "label": f"Hybrid // {hybrid_model_id}",
                            "value": hybrid_model_id,
                            "report": f"{name} - {created_at}",
                        }
                    )
                if knn_model_id:
                    models.append(
                        {
                            "id": knn_model_id,
                            "label": f"K-Nearest Neighors // {knn_model_id}",
                            "value": knn_model_id,
                            "report": f"{name} - {created_at}",
                        }
                    )
                if lgbm_model_id:
                    models.append(
                        {
                            "id": lgbm_model_id,
                            "label": f"LightGBM // {lgbm_model_id}",
                            "value": lgbm_model_id,
                            "report": f"{name} - {created_at}",
                        }
                    )

        # Load models from file
        try:
            saved_models = joblib.load("models_with_ids.pkl")
        except FileNotFoundError:
            saved_models = {}

        for model in models:
            saved_model = saved_models.get(model["id"])
            if saved_model:
                separator = saved_model.get("sep", ",")
                feature_columns = saved_model.get("feature_columns", [])
                model.update(
                    {
                        "feature_columns": separator.join(feature_columns),
                        "target_column": saved_model.get("target_column", None),
                    }
                )

        # Filter models that have matching IDs in saved models
        filtered_models = [
            model
            for model in models
            if any(id == model["id"] for id, details in saved_models.items())
        ]

        return jsonify({"items": filtered_models}), 200

    except Error as err:
        return jsonify({"error": str(err)}), 500
    finally:
        cursor.close()
        connection.close()


@app.route("/api/chain", methods=["POST"])
def chain():
    try:
        file = request.files["file"]
        model_id = request.form["model_id"]
        chain_name = request.form["chain_name"]

        malware_distribution, metrics, model_id = chain_model(
            file, model_id, chain_name
        )

        # Attempt to store metrics in the database
        report_id = None
        # try:
        #     report_id = store_metrics(
        #         malware_distribution,
        #         knn_metrics,
        #         lgbm_metrics,
        #         hybrid_metrics,
        #         model_ids,
        #         name,
        #         created_by,
        #     )
        # except Exception as store_error:
        #     return (
        #         jsonify({"error": "Failed to store metrics: " + str(store_error)}),
        #         500,
        #     )

        return (
            jsonify(
                {
                    "report_id": report_id,
                }
            ),
            200,
        )

    except Exception as e:
        return jsonify({"error": "An unexpected error occurred: " + str(e)}), 500


if __name__ == "__main__":
    app.run()
